---
title: "IDMfunction"
author: "Nidhi Ram"
date: "2025-06-25"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(readxl)
library(tidyverse)
library(sf) 
library(ggplot2) 
library(leaflet) 
library(dplyr) 
library(tigris) 
library(tidyr)
library(gt)
library(zipcodeR)
library(maps)
library(tidycensus)
library(terra)
library(exactextractr)
library(raster)
library(parallel)
library(brms)
library(eeptools)
library(gstat)

```

```{r, userdirectory, echo = TRUE, message=FALSE, warning=FALSE}

working_directory <- "/Users/nidhiram/Downloads/Summer 2025 Project"
print(working_directory)
setwd(working_directory)


```

# Intelligent Dasymetric Mapping for Spatial Allocation

# Function setup_counties
```{r}
setup_counties <- function(state_fips, crs) {
  us_counties <- counties(cb = TRUE)
  us_counties <- st_transform(us_counties, crs)
  region_counties <- us_counties %>%
    filter(STATEFP %in% state_fips)

  region_counties <- region_counties %>%
    mutate(FIPS = paste0(STATEFP, COUNTYFP))
  region_counties <- st_transform(region_counties, crs)

}

```

# Function make_grid
```{r}
make_grid <- function(region_counties, crs, grid_res) {
  region_counties <- st_transform(region_counties, crs)
  region_counties <- region_counties %>% 
    mutate(FIPS = paste0(STATEFP, COUNTYFP))
  
  ext <- ext(vect(region_counties))
  grid_rast <- rast(ext, resolution = grid_res, crs=crs)
  grid_vect <- mask(as.polygons(grid_rast), vect(region_counties))
  grid_sf <- st_as_sf(grid_vect)
}

us_counties_midwest <- st_transform(us_counties_midwest, 5070)
us_counties_midwest |> 
  st_union() -> Midwest
midwest_grid <- Midwest  |> 
  st_bbox() |>  
  st_make_grid(cellsize = 10000)   

ggplot() +
  geom_sf(
    data = midwest_states,
    fill = "white",
    color = "black"
  ) +
  geom_sf(
    data = midwest_grid,
  ) 
ggsave(filename = "us_counties.jpg", width = 7, height = 5)

midwest_grid |> 
  st_intersection(Midwest) -> midwest_grid
midwest_grid <- st_as_sf(midwest_grid)
midwest_grid <- st_transform(midwest_grid, 5070)
midwest_grid <- rename(midwest_grid, geometry = x)
minnesota_grid <- make_grid(minnesota_counties, crs = "EPSG:5070", grid_res = 10000)
midwest_grid <- make_grid(us_counties_midwest, crs = "EPSG:5070", grid_res = 10000)
mn_ia_grid <- make_grid(mn_ia_counties, crs = "EPSG:5070", grid_res = 10000)

us_cont_grid <- make_grid(us_counties_contiguous, crs = "EPSG:5070", grid_res = 10000)

```

# Function extract_landcover_prop
```{r}
extract_landcover_prop <- function(landcover_rast, grid_sf) {
  lc_summary <- exact_extract(landcover_rast, grid_sf, "frac", progress=TRUE)
  lc_summary <- lc_summary %>%
    rename(open_water=frac_11, developed_open = frac_21, developed_low = frac_22, developed_medium = frac_23, developed_high = frac_24, barren = frac_31, deciduous_forest = frac_41, evergreen_forest = frac_42, mixed_forest = frac_43, shrub = frac_52, grassland = frac_71, pastureland = frac_81, cropland = frac_82, woody_wetlands = frac_90, herbaceous_wetlands = frac_95)

}

lc_summary <- extract_landcover_prop(US_landcover, us_grid)

```

# Function uninhabited_flag
```{r}
uninhabited_flag <- function(lc_summary, uninhabited_classes, grid_sf, target_classes) {
  lc_summary <- lc_summary %>%
    mutate(uninhabited = rowSums(lc_summary[, uninhabited_classes, drop = FALSE], na.rm = TRUE))
  grid_sf <- bind_cols(grid_sf, lc_summary[, c(names(target_classes), "uninhabited"), drop = FALSE])
}

us_grid <- uninhabited_flag(lc_summary, uninhabited_classes = c("open_water", "barren", "woody_wetlands", "herbaceous_wetlands"), us_grid, target_classes = list(cropland = "cropland", pastureland = "pastureland"))
us_grid <- us_grid %>% rename(geometry = ...1)

```

# Function county_lc_summary (same as before)
```{r}
county_lc_summary <- function(landcover_rast, region_counties, target_classes, pred_var) {
  lc_summary_county <- exact_extract(landcover_rast, region_counties, "frac", progress=TRUE)
  lc_summary_county <- lc_summary_county %>%
    rename(open_water=frac_11, developed_open = frac_21, developed_low = frac_22, developed_medium = frac_23, developed_high = frac_24, barren = frac_31, deciduous_forest = frac_41, evergreen_forest = frac_42, mixed_forest = frac_43, shrub = frac_52, grassland = frac_71, pastureland = frac_81, cropland = frac_82, woody_wetlands = frac_90, herbaceous_wetlands = frac_95)
  
  for (class in names(target_classes)) {
    region_counties[[class]] <- lc_summary_county[[target_classes[[class]]]]
  }
  region_counties <- left_join(region_counties, pred_var, by = c("FIPS" = "FIPS"))

}

us_counties_contiguous <- county_lc_summary(US_landcover, us_counties_contiguous, target_classes = list(cropland = "cropland", pastureland = "pastureland"), census_farm_count)

```


# Function density_model
```{r}

density_model <- function(pred_var, target_classes, region_counties, grid_sf) {
  options(mc.cores = parallel::detectCores())
  
  # spatial adjacency matrix
  nb <- poly2nb(region_counties)
  M <- nb2mat(nb, style = "B", zero.policy = TRUE)
  region_counties$FIPS2 <- factor(region_counties$FIPS)
  rownames(M) <- levels(region_counties$FIPS2)
  colnames(M) <- levels(region_counties$FIPS2)
  
  # state id
  region_counties$state_id <- as.factor(region_counties$STATEFP)
  
  # log area for model
  region_counties <- region_counties %>%
    mutate(log_area = log(as.numeric(st_area(geometry)) / 1e6))  # km²
  
  fixed_effects <- paste(target_classes, collapse = " + ")
  offset_term <- paste0(" + offset(", region_counties$log_area, ")")
  variable <- names(pred_var)[2]
  n_states <- length(unique(region_counties$state_id))
  
  # add multilevel component if necessary (> 1 state in region_counties)
  group_term <- if (n_states > 1) "+ (1 | state_id)" else ""
  
  formula <- paste0(variable, " ~ ", fixed_effects, "+ offset(log_area) ", group_term, " + car(M, gr = FIPS2, type = 'icar')")
  priors = c(prior(normal(0, 1), class = "b"), prior(normal(0, 1), class = "sdcar"), prior(exponential(1), class = "shape"))    
  
  model <- brm(formula = bf(as.formula(formula)),
    data   = region_counties,
    data2  = list(M = M),
    family = negbinomial(),
    chains = 4,
    cores  = 4,
    prior = priors,
    seed   = 123, control = list(adapt_delta = 0.99, max_treedepth = 15))
  print(model)
  print(bayes_R2(model))
  print(pp_check(model, ndraws=50))
  
  # model <- brm(as.formula(formula), data=region_counties, family=negbinomial(), chains=4, refresh=0)
  #print(summary(model))
  #print(pp_check(model, ndraws = 500))
  
  densities <- exp(fixef(model)[, "Estimate"])
  for (class in names(target_classes)) {
    grid_sf[[paste0("weight_", class)]] <- grid_sf[[class]] * densities[[class]]
  }
  grid_sf$total_weight <- rowSums(dplyr::select(grid_sf, starts_with("weight_")) %>% mutate(across(everything(), as.numeric)), na.rm = TRUE)
  
  return(grid_sf)
}

us_cont_grid <- density_model(pred_var = census_farm_count, target_classes = list(cropland = "cropland", pastureland = "pastureland"), region_counties = us_counties_contiguous, grid_sf = us_cont_grid)

```
# Function uninhabited_mask
```{r}
uninhabited_mask <- function(grid_sf) {
  grid_sf <- grid_sf %>%
    mutate(total_weight = ifelse(uninhabited >= 0.99, 0, total_weight))
}

us_grid <- uninhabited_mask(us_grid)

```

# Function assign_fips
```{r}
assign_fips <- function(grid_sf, region_counties, pred_var) {
  grid_centroids <- st_centroid(grid_sf)
  grid_with_fips <- st_join(grid_centroids, dplyr::select(region_counties, FIPS), join = st_within) 
  missing <- is.na(grid_with_fips$FIPS)
  grid_intersect <- st_join(grid_sf[missing, ], dplyr::select(region_counties, FIPS), join = st_intersects, left=FALSE)
  grid_with_fips$FIPS <- ifelse(missing, grid_intersect$FIPS, grid_with_fips$FIPS)
  grid_sf$FIPS <- grid_with_fips$FIPS
  
  grid_sf <- grid_sf %>%
    left_join(region_counties %>% 
                dplyr::select(FIPS, !!names(pred_var)[3]) %>% 
                st_drop_geometry(), by = "FIPS")
}


us_grid <- assign_fips(us_grid, us_counties_contiguous, census_farm_count)

```
# Function county_allocation
```{r}
county_allocation <- function(grid_sf, pred_var) {
  grid_sf <- grid_sf %>%
    group_by(FIPS) %>%
    mutate(scaling_factor = !!sym(names(pred_var)[2]) / sum(total_weight, na.rm=TRUE),
           allocated_pop_density = total_weight * scaling_factor) %>%
    ungroup()
  return(grid_sf)
}

us_grid$area_km2 <- as.numeric(st_area(us_grid$geometry)) / 1e6

```


# Function idm_allocate
```{r}
idm_allocate <- function(region_counties, crs, grid_res, landcover_rast, target_classes, uninhabited_classes, pred_var) {
  grid_sf <- make_grid(region_counties, crs, grid_res)
  lc_summary <- extract_landcover_prop(landcover_rast, grid_sf)
  grid_sf <- uninhabited_flag(lc_summary, uninhabited_classes, grid_sf, target_classes)
  region_counties <- county_lc_summary(landcover_rast, region_counties, target_classes, pred_var)
  grid_sf <- density_model(pred_var, target_classes, region_counties, grid_sf)
  grid_sf <- uninhabited_mask(grid_sf)
  grid_sf <- assign_fips(grid_sf, region_counties, pred_var)
  grid_sf <- county_allocation(grid_sf, pred_var)
  
} 

us_grid <- idm_allocate(region_counties = us_counties_contiguous, crs = "EPSG:5070", grid_res = 10000, landcover_rast = US_landcover, target_classes = list(cropland = "cropland", pastureland = "pastureland"), uninhabited_classes = c("open_water", "barren", "woody_wetlands", "herbaceous_wetlands"), pred_var = census_farm_count)

```


# US Negative Binomial density_model

```{r}
library(spdep)
nb <- poly2nb(us_counties_contiguous)
M <- nb2mat(nb, style = "B", zero.policy = TRUE)
rownames(M) <- levels(us_counties_contiguous$FIPS2)
colnames(M) <- levels(us_counties_contiguous$FIPS2)
us_counties_contiguous$FIPS2 <- factor(us_counties_contiguous$FIPS)

us_counties_contiguous <- us_counties_contiguous %>%
  mutate(log_area = log(as.numeric(st_area(geometry)) / 1e6))  # km²
us_grid <- us_grid %>%
  mutate(log_area = log(as.numeric(st_area(geometry)) / 1e6))

fit_car <- brm(
  formula = bf(
    Number_of_Farms ~ cropland + pastureland + offset(log_area) + car(M, gr = FIPS2, type = "icar")),
  data   = us_counties_contiguous,
  data2  = list(M = M),
  family = negbinomial(),
  chains = 4,
  cores  = 4,
  seed   = 123, iter = 3000, warmup=1000, control = list(adapt_delta = 0.99, max_treedepth = 15))
print(fit_car)
bayes_R2(fit_car)
pp_check(fit_car, ndraws=50)
ggsave(filename = "negbinomialppctest.jpg",width = 10,height = 6.5)

density_cropland <- exp(fixef(fit_car)["cropland", "Estimate"])
density_pastureland <- exp(fixef(fit_car)["pastureland", "Estimate"])

us_grid[["weight_cropland"]] <- us_grid[["cropland"]] * density_cropland
us_grid[["weight_pastureland"]] <- us_grid[["pastureland"]] * density_pastureland

us_grid$total_weight <- us_grid$weight_cropland + us_grid$weight_pastureland 



```

## Plot
```{r, fig.align="center", echo = FALSE, fig.width = 14}

library(gridExtra)
g1 <- ggplot(us_grid) +
  geom_sf(aes(fill = allocated)) +
  scale_fill_viridis_c(option = "C", limits = c(0, 200), oob = scales::squish) +
  theme_minimal() +
  labs(title = "IDM-Allocated Number of Farms",
       fill = "Farms per Grid Cell") + 
  theme(plot.title = element_text(hjust = 0.5))

g2 <- ggplot() +
  geom_sf(data = us_grid, aes(fill = allocated)) +
  geom_sf(data = combined_cafos, aes(color = "Feedlots"), size = 0.1, alpha = 0.05) +
  scale_fill_viridis_c(option = "C") +
  scale_color_manual(values = c("Feedlots" = "white")) +                # Custom colors
  theme_minimal() +
  labs(title = "IDM-Allocated Farm Count and Feedlots",
       fill = "Farms per Grid Cell", color = "Legend") + 
    theme(plot.title = element_text(hjust = 0.5))

g3 <- ggplot(data = us_counties_contiguous) +
  geom_sf(aes(fill = Number_of_Farms), color = "black", lwd=0.2) +
  scale_fill_viridis_c(option = "plasma", na.value = "gray90") +
  labs(
    fill = "Farms per County",
    title = "Number of Farms by County"
  ) +
  theme_minimal() + 
  theme(plot.title = element_text(hjust = 0.5))

grid.arrange(g3, g1, nrow = 1, ncol=2)
ggsave(filename = "us_farm_allocation.jpg",width = 10,height = 6.5)
ggsave(filename = "us_farm_county.jpg",width = 10,height = 6.5)


```
